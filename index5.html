<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Circle and Shape Manipulation</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; }
    canvas { display: block; }
  </style>
</head>
<body>
  <button id="info" style="position: absolute; top: 10px; left: 10px; z-index: 100;">ℹ️ Info</button>
  <div id="infoModal" style="display: none; position: fixed; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center;">
    <div style="background-color: #333; color: #fff; padding: 20px; border-radius: 10px; width: 80%; max-width: 500px; position: relative;">
      <span id="closeModal" style="position: absolute; top: 10px; right: 15px; font-size: 20px; cursor: pointer;">&times;</span>
      <h3>Instruções de Uso</h3>
      <p>- Mão direita faz pinça para controlar o tamanho (raio) da forma.</p>
      <p>- Mão esquerda controla o número de lados e a distorção.</p>
      <p>- Distância entre indicador e médio da mão esquerda controla a escala da forma (largura e altura).</p>
      <p>- Gestos com dedos da mão direita próximos à borda distorcem dinamicamente a forma.</p>
      <p>- Teclas "+" e "-" também aumentam ou diminuem o tamanho.</p>
    </div>
  </div>
  <video id="video" style="display:none;" playsinline></video>
  <canvas id="canvas"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
    const videoElement = document.getElementById('video');
    const canvasElement = document.getElementById('canvas');
    const ctx = canvasElement.getContext('2d');

    function resizeCanvas() {
      canvasElement.width = window.innerWidth;
      canvasElement.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    let circleRadius = 100;
    let shapeSides = 100; // 100 = círculo
    let scaleX = 1;
    let scaleY = 1;
    let rightHandLandmarks = null; // For liquify effect
    const centerX = () => canvasElement.width / 2;
    const centerY = () => canvasElement.height / 2;

    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
      maxNumHands: 2,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.7
    });

    hands.onResults(onResults);

    const camera = new Camera(videoElement, {
      onFrame: async () => {
        await hands.send({ image: videoElement });
      },
      width: 640,
      height: 480
    });
    camera.start();

    document.addEventListener('keydown', (e) => {
      if (e.key === '+') {
        circleRadius = Math.min(circleRadius + 10, 300);
      }
      if (e.key === '-') {
        circleRadius = Math.max(circleRadius - 10, 30);
      }
    });

    const infoButton = document.getElementById('info');
    const infoModal = document.getElementById('infoModal');
    const closeModalButton = document.getElementById('closeModal');

    infoButton.addEventListener('click', () => {
      infoModal.style.display = 'flex'; // Use flex for centering
    });

    closeModalButton.addEventListener('click', () => {
      infoModal.style.display = 'none';
    });

    // Optional: Close modal if user clicks outside of it
    window.addEventListener('click', (event) => {
      if (event.target === infoModal) {
        infoModal.style.display = 'none';
      }
    });

    const drawLandmarks = (landmarks) => {
      const connections = [
        [0,1],[1,2],[2,3],[3,4],
        [0,5],[5,6],[6,7],[7,8],
        [5,9],[9,10],[10,11],[11,12],
        [9,13],[13,14],[14,15],[15,16],
        [13,17],[17,18],[18,19],[19,20],
        [0,17]
      ];
      ctx.strokeStyle = 'lime';
      ctx.lineWidth = 2;
      for (const [a, b] of connections) {
        const x1 = canvasElement.width - (landmarks[a].x * canvasElement.width);
        const y1 = landmarks[a].y * canvasElement.height;
        const x2 = canvasElement.width - (landmarks[b].x * canvasElement.width);
        const y2 = landmarks[b].y * canvasElement.height;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
    };

    function distance(x1, y1, x2, y2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function isTouchingCircle(x, y, cx, cy, r, tolerance = 20) {
      const d = distance(x, y, cx, cy);
      return Math.abs(d - r) <= tolerance;
    }

    function drawShape(cx, cy, radius, sides, currentScaleX, currentScaleY) {
      ctx.beginPath();
      const maxInfluenceDistance = 150; // px
      const maxForce = 25; // px, adjust for desired strength
      const fingertipsToUse = [4, 8, 12, 16, 20]; // Thumb, Index, Middle, Ring, Pinky

      for (let i = 0; i < sides; i++) {
        const angle = (i / sides) * Math.PI * 2;
        let vertexX_orig = radius * Math.cos(angle);
        let vertexY_orig = radius * Math.sin(angle);

        // Liquify effect
        let totalDisplacementX = 0;
        let totalDisplacementY = 0;

        if (rightHandLandmarks) {
          const currentVertexCanvasX = cx + vertexX_orig;
          const currentVertexCanvasY = cy + vertexY_orig;

          for (const landmarkIndex of fingertipsToUse) {
            const fingertip = rightHandLandmarks[landmarkIndex];
            const fingertipX = canvasElement.width - (fingertip.x * canvasElement.width); // Invert X
            const fingertipY = fingertip.y * canvasElement.height;

            const distToFingertip = distance(currentVertexCanvasX, currentVertexCanvasY, fingertipX, fingertipY);

            if (distToFingertip < maxInfluenceDistance && distToFingertip > 0) {
              const vecX = currentVertexCanvasX - fingertipX;
              const vecY = currentVertexCanvasY - fingertipY;

              const normVecX = vecX / distToFingertip;
              const normVecY = vecY / distToFingertip;

              const forceMagnitude = maxForce * (1 - distToFingertip / maxInfluenceDistance);

              totalDisplacementX += normVecX * forceMagnitude;
              totalDisplacementY += normVecY * forceMagnitude;
            }
          }
        }

        let deformedX = vertexX_orig + totalDisplacementX;
        let deformedY = vertexY_orig + totalDisplacementY;

        // Apply scaling AFTER deformation
        const finalX = cx + deformedX * currentScaleX;
        const finalY = cy + deformedY * currentScaleY;

        if (i === 0) ctx.moveTo(finalX, finalY);
        else ctx.lineTo(finalX, finalY);
      }
      ctx.closePath();
      ctx.strokeStyle = 'cyan';
      ctx.lineWidth = 4;
      ctx.stroke();
    }

    function onResults(results) {
      ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);

      const cx = centerX();
      const cy = centerY();

      // Reset rightHandLandmarks before processing results
      rightHandLandmarks = null;

      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        for (let i = 0; i < results.multiHandLandmarks.length; i++) {
          const landmarks = results.multiHandLandmarks[i];
          const handedness = results.multiHandedness[i].label; // "Left" ou "Right"

          if (handedness === "Right") {
            rightHandLandmarks = landmarks;
          }

          drawLandmarks(landmarks); // Desenha esqueleto

          const indexTip = landmarks[8];
          const thumbTip = landmarks[4];

          const ix = canvasElement.width - (indexTip.x * canvasElement.width);
          const iy = indexTip.y * canvasElement.height;
          const tx = canvasElement.width - (thumbTip.x * canvasElement.width);
          const ty = thumbTip.y * canvasElement.height;

          const pinchDistance = distance(ix, iy, tx, ty);
          const pinchX = (ix + tx) / 2;
          const pinchY = (iy + ty) / 2;

          // Mão direita controla o RAIO se a pinça estiver tocando o contorno
          if (handedness === "Right") {
            // The pinchDistance and related calculations are for the old radius logic.
            // We can keep it if there's no conflict, or decide if liquify replaces it.
            // For now, let's assume the pinch for radius change is still desired.
            if (distance(ix, iy, cx, cy) <= circleRadius + 50) {
                 const newRadius = Math.min(Math.max(pinchDistance * 2, 30), 300);
                 circleRadius = newRadius;
            }
          }

          // Mão esquerda controla a FORMA se a pinça estiver tocando o contorno
          // E também a distorção radial
          if (handedness === "Left") {
            const indexFingerTip = landmarks[8];
            const middleFingerTip = landmarks[12];

            // Normalizar coordenadas pela largura/altura do canvas para consistência
            const ifx = indexFingerTip.x; // Já normalizado (0-1)
            const ify = indexFingerTip.y; // Já normalizado (0-1)
            const mfx = middleFingerTip.x; // Já normalizado (0-1)
            const mfy = middleFingerTip.y; // Já normalizado (0-1)

            // Calcular distâncias normalizadas
            // Multiplicar por um fator para tornar a sensibilidade mais utilizável.
            // O fator de normalização (e.g., 1 / 0.2 = 5) é para mapear uma pequena distância
            // entre dedos (e.g. 0.2 da largura do canvas) para uma escala de 1.0.
            // Ajuste este fator conforme necessário.
            const normalizationFactor = 5; // Ajuste este valor para sensibilidade

            let newScaleX = Math.abs(ifx - mfx) * normalizationFactor;
            let newScaleY = Math.abs(ify - mfy) * normalizationFactor * (canvasElement.height / canvasElement.width); //Ajustar para aspect ratio

            // Clamping para evitar valores extremos
            scaleX = Math.min(Math.max(newScaleX, 0.1), 5);
            scaleY = Math.min(Math.max(newScaleY, 0.1), 5);


            if (isTouchingCircle(pinchX, pinchY, cx, cy, circleRadius)) {
              // Mapeia distância da pinça para número de lados (3 a 100)
              const newSides = Math.round(Math.min(Math.max((pinchDistance - 10) / 5 + 3, 3), 100));
              shapeSides = newSides;
            }
          }
        }
      }
      // Desenha a forma (círculo ou polígono) - Moved after landmark processing
      drawShape(cx, cy, circleRadius, shapeSides, scaleX, scaleY);
    }
  </script>
</body>
</html>
